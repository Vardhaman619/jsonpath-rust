main = { SOI ~ js_query ~ EOI }
js_query = {root ~ segments}
segments = {(S ~ segment)*}
segment = { child_segment | descendant_segment }
child_segment = { bracketed_selection | ("." ~ (wildcard_selector | member_name_shorthand)) }
bracketed_selection = { "[" ~ S ~ selector ~ (S ~ "," ~ S ~ selector)* ~ S ~ "]" }
descendant_segment = { ".."}
selector = {name_selector | wildcard_selector | index_selector | slice_selector | filter_selector}

root = {"$"}
name_selector = {string_literal}
wildcard_selector   = _{"*"}
index_selector   = {int}
int = _{ "0" | ("-"? ~ DIGIT1 ~ DIGIT*) }
slice_selector = { int? ~ S ~ ":" ~ S ~ int? ~ S ~ (":" ~ S ~ int?)? }
filter_selector = {"?"~ S ~ logical_expr_or}
logical_expr_or = {logical_expr_and ~ S ~ ("||" ~ S ~ logical_expr_and)*}
logical_expr_and = {atom_expr ~ S ~ ("&&" ~ S ~ atom_expr)*}
atom_expr = {paren_expr | comp_expr| test_expr}
paren_expr = {not_op? ~ S ~ "(" ~ S ~ logical_expr_or ~ S ~ ")"}
test_expr = {not_op? ~ S ~ (filter_query | function_expr)}
filter_query = {rel_query | js_query}
rel_query = {curr ~ S ~ segments}
comp_expr = { comparable ~ S ~ comp_op ~ S ~ comparable }
literal = { number | string_literal | "true" | "false" | "null" }
comparable = { literal | singular_query | function_expr }
singular_query = { rel_singular_query | abs_singular_query }
rel_singular_query = { curr ~ singular_query_segments }
abs_singular_query = { root ~ singular_query_segments }
singular_query_segments = { (S ~ (name_segment | index_segment))* }
name_segment = { ("[" ~ name_selector ~ "]") | ("." ~ member_name_shorthand) }
index_segment = { "[" ~ index_selector ~ "]" }
comp_op = { "==" | "!=" | "<=" | ">=" | "<" | ">" }
function_name = { function_name_first ~ function_name_char* }
function_name_first = { LCALPHA }
function_name_char = { function_name_first | "_" | DIGIT }
LCALPHA = { 'a'..'z' }
function_expr = { function_name ~ "(" ~ S ~ (function_argument ~ (S ~ "," ~ S ~ function_argument)*)? ~ S ~ ")" }
function_argument = { literal | filter_query | logical_expr_or | function_expr }
string_literal = _{ "\"" ~ double_quoted* ~ "\"" | "\'" ~ single_quoted* ~ "\'" }
double_quoted = _{ unescaped | "\'" | ESC ~ "\"" | ESC ~ escapable }
single_quoted = _{ unescaped | "\"" | ESC ~ "\'" | ESC ~ escapable }
escapable = _{
    "b" | "f" | "n" | "r" | "t" | "/" | "\\" | ("u" ~ hexchar)
}

member_name_shorthand = { name_first ~ name_char* }
name_first = { ALPHA | "_" | '\u{0080}'..'\u{D7FF}' | '\u{E000}'..'\u{10FFFF}' }
name_char = { name_first | DIGIT }
not_op = {"!"}
curr = {"@"}
ESC = _{ "\\" }
unescaped = _{
    '\u{0020}'..'\u{0021}' |
    '\u{0023}'..'\u{0026}' |
    '\u{0028}'..'\u{005B}' |
    '\u{005D}'..'\u{D7FF}' |
    '\u{E000}'..'\u{10FFFF}'
}

S = _{ WHITESPACE* }
hexchar = _{ non_surrogate | (high_surrogate ~ "\\" ~ "u" ~ low_surrogate) }
number = { (int | "-0") ~ frac? ~ exp? }
frac = { "." ~ DIGIT+ }
exp = { "e" ~ ("-" | "+")? ~ DIGIT+ }
non_surrogate = _{ (DIGIT | "A" | "B" | "C" | "E" | "F") ~ HEXDIG{3} | ("D" ~ ('0'..'7') ~ HEXDIG{2}) }

high_surrogate = _{ "D" ~ ("8" | "9" | "A" | "B") ~ HEXDIG{2} }

low_surrogate = _{ "D" ~ ("C" | "D" | "E" | "F") ~ HEXDIG{2} }

HEXDIG = _{ DIGIT | "A" | "B" | "C" | "D" | "E" | "F" }
DIGIT = _{ ASCII_DIGIT }
DIGIT1 = _{ ASCII_NONZERO_DIGIT}
ALPHA = { ASCII_ALPHA }
WHITESPACE = _{ " " | "\t" | "\r\n" | "\n" | "\r"}
